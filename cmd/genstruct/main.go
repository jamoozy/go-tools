// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/go-yaml/yaml"
)

var indent = ""

func trc(name string) func() {
	db("%s --> %s", indent, name)
	indent += "  "
	return func() {
		indent = strings.TrimSuffix(indent, "  ")
		db("%s <-- %s", indent, name)
	}
}

func lg(fmtStr string, args ...interface{}) {
	args = append([]interface{}{indent}, args...)
	log.Printf("%s"+fmtStr, args...)
}

func db(fmtStr string, args ...interface{}) {
	if *debug {
		lg(fmtStr, args...)
	}
}

func isStdIO(v string) bool {
	return v == "-"
}

// CL flags.
var (
	iname = flag.String("i", "-", `Name of file to read from. "-" for stdin.`)
	oname = flag.String("o", "-", `Name of file to generate. "-" for stdout.`)
	ename = flag.String("e", "-", `Name of the file to log errors to. "-" for stderr.`)

	debug = flag.Bool("d", false, `Enable debugging output.`)
)

type GenStruct struct {
	Out     *os.File
	Err     *log.Logger
	Structs map[string]*Struct
	Order   []string
}

func (gs *GenStruct) printf(fmtStr string, args ...interface{}) {
	if _, err := fmt.Fprintf(gs.Out, fmtStr, args...); err != nil {
		gs.Err.Fatalf(err.Error())
	}
}

type Struct struct {
	Name   string
	Fields map[string]*Field
}

type Field struct {
	OmitEmpty       bool
	Name, Type, Tag string
}

// On collisions, just take the union of the fields and use omitempty.
func (gs *GenStruct) add(s *Struct) (err error) {
	if t, ok := gs.Structs[s.Name]; ok {
		var setOE bool
		for name, f := range s.Fields {
			if g, ok := t.Fields[name]; !ok {
				t.Fields[name] = s.Fields[name]
			} else {
				if !reflect.DeepEqual(f, g) {
					return fmt.Errorf("Fields differ: %#v != %#v", f, g)
				}
				setOE = true
			}
		}

		if setOE {
			for _, f := range t.Fields {
				f.OmitEmpty = true
			}
		}
	} else {
		gs.Structs[s.Name] = s
		gs.Order = append(gs.Order, s.Name)
	}
	return
}

func (gs *GenStruct) printAll() (err error) {
	gs.printf("// Package tmp was auto-generated by genstruct and should not be used by anyone.\npackage tmp\n\n")

	for _, s := range gs.Structs {
		if len(s.Fields) == 0 {
			lg("Printing %s with 0 known fields ...", s.Name)
			gs.printf("// %s needs documentation...\ntype %s map[string]interface{}\n\n", s.Name, s.Name)
			continue
		}
		gs.printf("// %s needs documentation...\ntype %s struct {\n", s.Name, s.Name)

		lg("Printing %s with %d fields ...", s.Name, len(s.Fields))
		for _, f := range s.Fields {
			tag := f.Tag
			typ := f.Type
			if f.OmitEmpty {
				tag += ",omitempty"
				if !strings.HasPrefix(typ, "[]") && !strings.HasPrefix(typ, "map[") {
					typ = "*" + typ
				}
			}
			gs.printf("\t%s %s `json:%q`\n", f.Name, typ, tag)
		}
		gs.printf("}\n\n")
	}
	return
}

func main() {
	flag.Parse()

	var (
		e   *log.Logger
		i   io.Reader
		o   *os.File
		err error
	)

	if isStdIO(*ename) {
		e = log.New(os.Stderr, "", 0)
	} else {
		f, err := os.Create(*ename)
		if err != nil {
			log.Printf("Cannot open file %q: %s", *ename, err.Error())
			return
		}
		e = log.New(f, "", 0)
	}

	if isStdIO(*iname) {
		i = os.Stdin
	} else if i, err = os.Open(*iname); err != nil {
		e.Fatalf(err.Error())
	}

	if isStdIO(*oname) {
		o = os.Stdout
		defer o.Sync()
	} else if o, err = os.Create(*oname); err != nil {
		e.Fatalf(err.Error())
	} else {
		defer o.Close()
	}

	m, err := read(i)
	if err != nil {
		e.Fatalf(err.Error())
	}

	gs := &GenStruct{
		Err:     e,
		Out:     o,
		Structs: map[string]*Struct{},
		Order:   make([]string, 0, 2*len(m)),
	}
	if _, err := gs.genStruct("TopLevelElement", m); err != nil {
		e.Fatalf(err.Error())
	}

	if err := gs.printAll(); err != nil {
		e.Fatalf(err.Error())
	}
}

func (gs *GenStruct) genStruct(name string, m map[string]interface{}) (string, error) {
	defer trc("genStruct")()

	var (
		s = &Struct{
			Name:   strings.Title(name),
			Fields: map[string]*Field{},
		}
		err error
	)

	for k, v := range m {
		f := &Field{
			Name: strings.Title(k),
			Tag:  k,
		}

		switch v := v.(type) {
		case bool:
			f.Type = "bool"
			db("%q is %s", k, f.Type)

		case float32, float64,
			int, int8, int16, int32, int64,
			uint, uint8, uint16, uint32, uint64:
			f.Type = "float64"
			db("%q is %s", k, f.Type)

		case string:
			f.Type = "string"
			db("%q is %s", k, f.Type)

		case []interface{}:
			f.Type, err = gs.genSlice(k, v)
			if err != nil {
				return "", err
			}
			db("%q is %s", k, f.Type)

		case map[string]interface{}:
			f.Type, err = gs.genStruct(k, v)
			if err != nil {
				return "", err
			}
			db("%q is %s", k, f.Type)

		default:
			return "", fmt.Errorf("Unrecognized type: %T", v)
		}

		s.Fields[f.Name] = f
	}

	gs.add(s)
	return s.Name, nil
}

func (gs *GenStruct) genSlice(name string, s []interface{}) (string, error) {
	defer trc("genSlice")()

	var (
		t, last string
		err     error
	)

	// TODO
	singularize := func(i string) string {
		return i
	}

	for _, v := range s {
		switch v := v.(type) {
		case bool:
			last = t
			t = "bool"

		case float32, float64,
			int, int8, int16, int32, int64,
			uint, uint8, uint16, uint32, uint64:
			last = t
			t = "float64"

		case string:
			last = t
			t = "string"

		case []interface{}:
			last = t
			t, err = gs.genSlice(name, v)
			if err != nil {
				return "", err
			}

		case map[string]interface{}:
			last = t
			t, err = gs.genStruct(singularize(name), v)
			if err != nil {
				return "", err
			}

		default:
			return "", fmt.Errorf("Unrecognized type: %T", v)
		}

		if last != "" && last != t {
			t = "interface{}"
		}
	}

	if t == "" {
		t = "interface{}"
	}

	return "[]" + t, nil
}

func read(i io.Reader) (map[string]interface{}, error) {
	b, err := ioutil.ReadAll(i)
	if err != nil {
		return nil, err
	}

	parsers := map[string]func(i []byte, o interface{}) error{
		"json": json.Unmarshal,
		"yaml": yaml.Unmarshal,
	}
	names := make([]string, 0, len(parsers))

	var m map[string]interface{}
	for t, f := range parsers {
		if err := f(b, &m); err == nil {
			return m, nil
		}
		names = append(names, t)
	}
	return nil, fmt.Errorf("Could not parse after trying parsers for: %q", names)
}
